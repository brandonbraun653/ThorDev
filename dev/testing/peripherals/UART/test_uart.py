import unittest

import os
import re
import sys
import time
import erpc
import serial
import _thread
import threading
import subprocess
import CppHeaderParser

from stlink import STLink_USBInterface, STLink
from erpcgen_files.py.uart_rpc import client

rpc_port = "/dev/ttyUSB0"
ser_port = "/dev/ttyUSB1"

stm32_device_serial = 303636464646353235373530383737

dir_path = os.path.dirname(os.path.realpath(__file__))

debug_binary = os.path.join(dir_path, "build/debug/test_uart.bin")
release_binary = os.path.join(dir_path, "build/release/test_uart.bin")


def get_usb_devices():
    """
    Finds all the connected usb devices on the computer and reports them back in a neat dictionary
    Courtesy of:
        1) https://goo.gl/m52UG7
        2) https://goo.gl/yXziE6
    """

    # Get every device on the bus
    device_re = re.compile("Bus\s+(?P<bus>\d+)\s+Device\s+(?P<device>\d+).+ID\s(?P<id>\w+:\w+)\s(?P<tag>.+)$", re.I)
    df = subprocess.check_output("lsusb")
    devices = []

    for i in df.decode().split('\n'):
        if i:
            info = device_re.match(i)
            if info:
                dinfo = info.groupdict()
                dinfo['device'] = '/dev/bus/usb/%s/%s' % (dinfo.pop('bus'), dinfo.pop('device'))
                devices.append(dinfo)

    return devices


def quit_function(fn_name):
    print('{0} took too long'.format(fn_name), file=sys.stderr)
    sys.stderr.flush()
    _thread.interrupt_main()


def exit_after(s):
    """
    Decorator to cancel a function after 's' seconds
    :param s: seconds before cancel
    """
    def outer(fn):
        def inner(*args, **kwargs):
            timer = threading.Timer(s, quit_function, args=[fn.__name__])
            timer.start()
            try:
                result = fn(*args, **kwargs)
            finally:
                timer.cancel()
            return result
        return inner
    return outer


class TestUART(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        """
        Check for device existence, can connect, gives ack, etc.
        :return:
        """
        # ----------------------------------
        # Project Source Code Setup
        # ----------------------------------
        subprocess.run("make -j8 release", shell=True)

        # ----------------------------------
        # STLink Setup
        # ----------------------------------
        # Generate the USB interface
        usb = STLink_USBInterface()
        usb.discover_devices()
        usb.attach_device_by_serial(stm32_device_serial)
        usb.save_device("stm32f767zit", "test.json")
        usb.load_device("test.json")

        # Attach the usb interface to the programmer
        cls.stlink = STLink(usb)

        # ----------------------------------
        # Flash the correct binary
        # ----------------------------------
        cls.stlink.flash(release_binary)
        cls.stlink.reset()

        # ----------------------------------
        # RPC Setup
        # ----------------------------------
        # Grab the correct crc from the autogenerated header file
        cls.crcHeader = CppHeaderParser.CppHeader("./erpcgen_files/src/erpc_crc16.h")
        for define in cls.crcHeader.defines:
            if 'ERPC_GENERATED_CRC' in define:
                cls.crc_value = int(define.split(' ')[1])

        # Using the CRC value, create a new serial transport instance. This will always be @ 115200 baud
        cls.transport = erpc.transport.SerialTransport(rpc_port, 115200)
        cls.transport.crc_16 = cls.crc_value

        # Create the client that actually talks to the DUT
        cls.client_manager = erpc.client.ClientManager(cls.transport, erpc.basic_codec.BasicCodec)
        cls.client_instance = client.TEST_UARTClient(cls.client_manager)

        # Start up the server & validate it is live
        cls.client_instance.setupSerialUnderTest()
        time.sleep(1)
        cls.ping_rpc_server(cls)

        # ----------------------------------
        # Serial Port (for validation)
        # ----------------------------------
        cls.serialPort = serial.Serial(
            port=ser_port,
            baudrate=115200,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            bytesize=serial.EIGHTBITS,
            timeout=2.0)

    @classmethod
    def tearDownClass(cls):
        """
        Clean up operations
        :return:
        """
        pass


    def ping_rpc_server(self):
        result = self.client_instance.turnGreenLEDON()

    def setUpModule(self):
        """
        Put the MCU into a known state before running next test
        :return:
        """
        pass

    def tearDownModule(self):
        """
        Put the MCU into a known state before running next test
        :return:
        """
        pass

    @exit_after(10)
    def test_BlockingTX(self):
        expected_response = b'Hello World\r\n'
        self.client_instance.testStart_blockingTX()

        while True:
            data = self.serialPort.readline()
            print(data)

            if data == expected_response:
                break

            time.sleep(0.5)

        self.assertTrue((data == expected_response), "Unable to get the correct UART blocking TX response")

        self.client_instance.testEnd_blockingTX()

    def test_BlockingRX(self):
        pass

    def test_InterruptTX(self):
        pass

    def test_InterruptRX(self):
        pass

    def test_DmaTX(self):
        pass

    def test_DmaRX(self):
        pass




if __name__ == '__main__':
    unittest.main()
