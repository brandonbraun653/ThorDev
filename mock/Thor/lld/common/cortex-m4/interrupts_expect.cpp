/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -s c++20
 */

#include "interrupts_expect.hpp"

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& setPriorityGrouping(CppUMockGen::Parameter<const uint32_t> priorityGroup)
{
    return setPriorityGrouping(1, priorityGroup);
}
MockExpectedCall& setPriorityGrouping(unsigned int __numCalls__, CppUMockGen::Parameter<const uint32_t> priorityGroup)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::setPriorityGrouping");
    if(priorityGroup.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("priorityGroup", priorityGroup.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& getPriorityGrouping(uint32_t __return__)
{
    return getPriorityGrouping(1, __return__);
}
MockExpectedCall& getPriorityGrouping(unsigned int __numCalls__, uint32_t __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::getPriorityGrouping");
    __expectedCall__.andReturnValue(static_cast<unsigned int>(__return__));
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& setPriority(CppUMockGen::Parameter<const IRQn_Type> IRQn, CppUMockGen::Parameter<const uint32_t> preemptPriority, CppUMockGen::Parameter<const uint32_t> subPriority)
{
    return setPriority(1, IRQn, preemptPriority, subPriority);
}
MockExpectedCall& setPriority(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn, CppUMockGen::Parameter<const uint32_t> preemptPriority, CppUMockGen::Parameter<const uint32_t> subPriority)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::setPriority");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    if(preemptPriority.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("preemptPriority", preemptPriority.getValue()); }
    if(subPriority.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("subPriority", subPriority.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& getPriority(CppUMockGen::Parameter<const IRQn_Type> IRQn, CppUMockGen::Parameter<const uint32_t> priorityGroup, uint32_t *const preemptPriority, size_t __sizeof_preemptPriority, uint32_t *const subPriority, size_t __sizeof_subPriority)
{
    return getPriority(1, IRQn, priorityGroup, preemptPriority, __sizeof_preemptPriority, subPriority, __sizeof_subPriority);
}
MockExpectedCall& getPriority(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn, CppUMockGen::Parameter<const uint32_t> priorityGroup, uint32_t *const preemptPriority, size_t __sizeof_preemptPriority, uint32_t *const subPriority, size_t __sizeof_subPriority)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::getPriority");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    if(priorityGroup.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("priorityGroup", priorityGroup.getValue()); }
    __expectedCall__.withOutputParameterReturning("preemptPriority", preemptPriority, __sizeof_preemptPriority);
    __expectedCall__.withOutputParameterReturning("subPriority", subPriority, __sizeof_subPriority);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& enableIRQ(CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    return enableIRQ(1, IRQn);
}
MockExpectedCall& enableIRQ(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::enableIRQ");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& disableIRQ(CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    return disableIRQ(1, IRQn);
}
MockExpectedCall& disableIRQ(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::disableIRQ");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& setPendingIRQ(CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    return setPendingIRQ(1, IRQn);
}
MockExpectedCall& setPendingIRQ(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::setPendingIRQ");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& clearPendingIRQ(CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    return clearPendingIRQ(1, IRQn);
}
MockExpectedCall& clearPendingIRQ(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::clearPendingIRQ");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& getPendingIRQ(CppUMockGen::Parameter<const IRQn_Type> IRQn, uint32_t __return__)
{
    return getPendingIRQ(1, IRQn, __return__);
}
MockExpectedCall& getPendingIRQ(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn, uint32_t __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::getPendingIRQ");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    __expectedCall__.andReturnValue(static_cast<unsigned int>(__return__));
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& getActive(CppUMockGen::Parameter<const IRQn_Type> IRQn, uint32_t __return__)
{
    return getActive(1, IRQn, __return__);
}
MockExpectedCall& getActive(unsigned int __numCalls__, CppUMockGen::Parameter<const IRQn_Type> IRQn, uint32_t __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::getActive");
    if(IRQn.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("IRQn", static_cast<int>(IRQn.getValue())); }
    __expectedCall__.andReturnValue(static_cast<unsigned int>(__return__));
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace Thor$ { namespace LLD$ { namespace INT$ {
MockExpectedCall& SystemReset()
{
    return SystemReset(1);
}
MockExpectedCall& SystemReset(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Thor::LLD::INT::SystemReset");
    return __expectedCall__;
}
} } } }

